[vars]
python_version = "$(cat .python-version 2>/dev/null || echo 'Error: .python-version not found')"
uv = 'uv'
text_red = '\033[0;31m'
text_green = '\033[0;32m'
text_yellow = '\033[0;33m'
text_blue = '\033[0;34m'
text_magenta = '\033[0;35m'
text_cyan = '\033[0;36m'
text_white = '\033[0;37m'
text_reset = '\033[0m'

[env]
DOCKER_BUILDKIT = "1"
COMPOSE_DOCKER_CLI_BUILD = "1"

########################
# 環境構築・初期化タスク #
########################

[tasks.init]
description = "初期化処理（仮想環境を作成し、依存関係をインストール）"
shell = "bash -c"
quiet = true
depends = ["venv"]
run = '''
if [ -d "{{env.MISE_CONFIG_ROOT}}/.venv" ] \
  && [ ! -f "{{env.MISE_CONFIG_ROOT}}/.venv/bin/python" ] \
  && [ ! -f "{{env.MISE_CONFIG_ROOT}}/.venv/Scripts/python.exe" ]; then
  echo "virtual environment is broken. Recreating..."
  mise run reset-venv
fi

{{vars.uv}} lock
{{vars.uv}} sync --all-extras

printf "✅ プロジェクトの初期化が完了しました"
'''

[tasks.venv]
description = "uvを利用して仮想環境を作成します"
shell = "bash -c"
quiet = true
hide = true
run = '''
if [ ! -d "{{env.MISE_CONFIG_ROOT}}/.venv" ]; then
  echo "Creating .venv with Python {{vars.python_version}} ..."
  {{vars.uv}} venv --python {{vars.python_version}} --clear
else
  echo "Use existing .venv"
fi
'''

[tasks.reset-venv]
description = "仮想環境をリセットします"
shell = "bash -c"
quiet = true
run = '''
echo "Resetting .venv ..."
venv_dir="{{env.MISE_CONFIG_ROOT}}/.venv"
if [ -d "$venv_dir" ]; then
  echo "Removing existing .venv ...";
  chmod -R +w "$venv_dir" 2>/dev/null || true;
  find "$venv_dir" -type l -delete 2>/dev/null || true;
  find "$venv_dir" -type f -exec chmod +w {} \; 2>/dev/null || true;
  rm -rf "$venv_dir" 2>/dev/null || sudo rm -rf "$venv_dir" || true;
fi
{{vars.uv}} venv --python {{vars.python_version}} --clear
echo "done. Run 'mise run init' to sync dependencies."
'''

[tasks.upgrade]
description = "依存関係を最新のバージョンにアップグレードします"
shell = "bash -c"
quiet = true
depends = ["venv"]
run = '''
{{vars.uv}} sync --upgrade --all-extras
printf "✅ 依存関係のアップグレードが完了しました\n"
'''

######################
# Code Quality Tasks #
######################

[tasks.check]
description = "コードの静的解析とテストを実行します"
shell = "bash -c"
quiet = true
run = '''
printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running ruff check..."
{{vars.uv}} run ruff check .
printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running mypy..."
{{vars.uv}} run mypy .

printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running ty check..."
{{vars.uv}} run ty check .
printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running vulture..."
targets=""
[ -d src ] && targets="$targets src"
[ -d tests ] && targets="$targets tests"
[ -z "$targets" ] && targets="."
whitelist_paths=""
if [ -f vulture/whitelists/local.py ]; then
  whitelist_paths="vulture/whitelists/local.py"
fi
{{vars.uv}} run vulture --min-confidence 90 $targets $whitelist_paths

printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running pytest..."
{{vars.uv}} run pytest tests/
printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running yamllint..."
{{vars.uv}} run yamllint . # .yamllint.yml は自動的に読み込まれる

if command -v shellcheck >/dev/null 2>&1; then
  printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "Running shellcheck..."
  shellcheck_files=()
  while IFS= read -r -d '' file; do
    shellcheck_files+=("$file")
  done < <(find . -type f \( -name "*.sh" -o -name "*.bash" \) -not -path "./.venv/*" -not -path "./node_modules/*" -not -path "./.git/*" -print0)
  if [ "${shellcheck_files[0]+_}" ]; then
    shellcheck -x -P SCRIPTDIR "${shellcheck_files[@]}"
  else
    printf "{{vars.text_yellow}}%s{{vars.text_reset}}\n" "No shell scripts found; skipping shellcheck."
  fi
else
  printf "{{vars.text_red}}%s{{vars.text_reset}}\n" "shellcheck is not installed; skipping shell script linting."
fi
'''

[tasks.format]
description = "コードのフォーマットを実行します"
shell = "bash -c"
quiet = true
run = '''
{{vars.uv}} run ruff format .
{{vars.uv}} run ruff check . --fix
'''

[tasks.ruff-clean]
description = "Ruff のキャッシュを削除します"
shell = "bash -c"
quiet = true
run = '''
{{vars.uv}} run ruff clean
'''

#######################
# Encrypt And Decrypt #
#######################

[tasks.encrypt]
description = "ファイル・フォルダを暗号化します"
shell = "bash -c"
quiet = true
run = '''
TARGET={{arg(name="target", description="暗号化するフォルダのパス")}}
if [[ ! -e "$TARGET" ]]; then
  echo "Error: target '$TARGET' is not a file or directory"
  exit 1
fi
{{vars.uv}} run python scribe/zipper.py -e -c "$TARGET"
'''

[tasks.decrypt]
description = "ファイル・フォルダを復号化します"
shell = "bash -c"
quiet = true
run = '''
TARGET={{arg(name="target", description="復号化するフォルダのパス")}}
if [[ ! -e "$TARGET" ]]; then
  echo "Error: target '$TARGET' is not a file or directory"
  exit 1
fi
{{vars.uv}} run python scribe/zipper.py -x "$TARGET"
'''

################################################
# Multiple Python Version Support using Docker #
################################################
[tasks.docker-build]
description = "compose build（コード変更時のみ再ビルド、BuildKitキャッシュ利用）"
shell = "bash -c"
quiet = true
sources = [
  "Docker/Dockerfile",
  "Docker/compose.yml",
  "pyproject.toml",
  "uv.lock",
  "scribe/**/*",
  "tests/**/*",
]
outputs = ["Docker/.cache/build_cache"]
run = '''
state_dir="Docker/.cache"
mkdir -p "$state_dir"

# BuildKit のローカルキャッシュを共有しつつビルド
docker compose --progress=plain -f Docker/compose.yml build \
  --build-arg BUILDKIT_INLINE_CACHE=1

date > "$state_dir/build_cache"
'''

[tasks.docker-up]
description = "docker コンテナを起動します"
shell = "bash -c"
quiet = true
depends = ["docker-build"]
sources = ["Docker/compose.yml", "Docker/.cache/build_cache"]
outputs = ["Docker/.cache/run_cache"]
run = '''
mkdir -p Docker/.cache
docker compose -f Docker/compose.yml down --volumes --remove-orphans
docker compose -f Docker/compose.yml up --detach --wait
date > Docker/.cache/run_cache
'''

[tasks.docker-test]
description = "docker コンテナ上でコードの静的解析とテストを実行します"
shell = "bash -c"
quiet = true
depends = ["docker-up"]
run = '''
versions=("3.11" "3.12" "3.13" "3.14")
for version in ${versions[@]}; do
  printf "{{vars.text_cyan}}%s{{vars.text_reset}}\n" "=== Testing on Python $version ==="
  service=python_${version//./_}
  docker compose -f Docker/compose.yml exec "$service" bash -c '
    set -e
    uv run ruff check .
    uv run mypy .
    uv run pytest tests/
  '
done
'''

[tasks.docker-down]
description = "docker コンテナを停止します"
shell = "bash -c"
quiet = true
run = '''
docker compose -f Docker/compose.yml down --volumes --remove-orphans || true
rm -f Docker/.cache/run_cache
'''

[tasks.docker-clean]
description = "docker ビルドキャッシュとコンテナを削除します"
shell = "bash -c"
quiet = true
run = '''
docker compose -f Docker/compose.yml down --rmi all --volumes --remove-orphans || true
docker builder prune --force
rm -rf Docker/.cache
'''
